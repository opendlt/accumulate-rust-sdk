// GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

//! JSON-RPC 2.0 client implementation

use std::collections::HashMap;

use reqwest::Client;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use thiserror::Error;
use uuid::Uuid;

/// JSON-RPC client error
#[derive(Error, Debug)]
pub enum JsonRpcError {
    #[error("HTTP error: {0}")]
    Http(#[from] reqwest::Error),

    #[error("JSON serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("RPC error {code}: {message}")]
    Rpc { code: i32, message: String, data: Option<Value> },

    #[error("Invalid response format")]
    InvalidResponse,
}

/// JSON-RPC request
#[derive(Debug, Serialize)]
struct JsonRpcRequest {
    jsonrpc: String,
    method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    params: Option<Value>,
    id: String,
}

/// JSON-RPC response
#[derive(Debug, Deserialize)]
struct JsonRpcResponse {
    jsonrpc: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    result: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<JsonRpcErrorInfo>,
    id: Value,
}

/// JSON-RPC error information
#[derive(Debug, Deserialize)]
struct JsonRpcErrorInfo {
    code: i32,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<Value>,
}

/// JSON-RPC 2.0 client
pub struct JsonRpcClient {
    client: Client,
    server_url: String,
}

impl JsonRpcClient {
    /// Create a new JSON-RPC client
    pub fn new(server_url: impl Into<String>) -> Self {
        Self {
            client: Client::new(),
            server_url: server_url.into(),
        }
    }

    /// Create a new JSON-RPC client with a custom HTTP client
    pub fn with_client(server_url: impl Into<String>, client: Client) -> Self {
        Self {
            client,
            server_url: server_url.into(),
        }
    }

    /// Make a JSON-RPC call
    pub async fn call(&self, method: &str, params: Option<Value>) -> Result<Value, JsonRpcError> {
        let request_id = Uuid::new_v4().to_string();
        let request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            method: method.to_string(),
            params,
            id: request_id,
        };

        let response = self
            .client
            .post(&self.server_url)
            .header("Content-Type", "application/json")
            .json(&request)
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(JsonRpcError::Http(reqwest::Error::from(
                response.error_for_status().unwrap_err(),
            )));
        }

        let response_data: JsonRpcResponse = response.json().await?;

        if let Some(error) = response_data.error {
            return Err(JsonRpcError::Rpc {
                code: error.code,
                message: error.message,
                data: error.data,
            });
        }

        response_data.result.ok_or(JsonRpcError::InvalidResponse)
    }

    /// Make a batch JSON-RPC call
    pub async fn batch(&self, requests: Vec<(&str, Option<Value>)>) -> Result<Vec<Value>, JsonRpcError> {
        let batch_request: Vec<JsonRpcRequest> = requests
            .into_iter()
            .enumerate()
            .map(|(i, (method, params))| JsonRpcRequest {
                jsonrpc: "2.0".to_string(),
                method: method.to_string(),
                params,
                id: i.to_string(),
            })
            .collect();

        let response = self
            .client
            .post(&self.server_url)
            .header("Content-Type", "application/json")
            .json(&batch_request)
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(JsonRpcError::Http(reqwest::Error::from(
                response.error_for_status().unwrap_err(),
            )));
        }

        let response_data: Vec<JsonRpcResponse> = response.json().await?;
        let mut results = Vec::new();

        for item in response_data {
            if let Some(error) = item.error {
                return Err(JsonRpcError::Rpc {
                    code: error.code,
                    message: error.message,
                    data: error.data,
                });
            }
            results.push(item.result.ok_or(JsonRpcError::InvalidResponse)?);
        }

        Ok(results)
    }
}