// GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

use crate::json_rpc_client::{JsonRpcClient, JsonRpcError, canonical_json};
use crate::types::*;
use crate::AccOptions;
use crate::codec::{
    TransactionEnvelope, TransactionHeader, TransactionSignature, TransactionCodec,
    TransactionBodyBuilder, TokenRecipient, AccumulateHash, UrlHash
};
use anyhow::Result;
use ed25519_dalek::{Keypair, Signer, Signature};
use reqwest::Client;
use serde_json::{json, Value};
use sha2::{Sha256, Digest};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};
use url::Url;

/// Main client for Accumulate blockchain API
#[derive(Debug, Clone)]
pub struct AccumulateClient {
    pub v2_client: JsonRpcClient,
    pub v3_client: JsonRpcClient,
    pub options: AccOptions,
}

impl AccumulateClient {
    /// Create a new client with custom options
    pub async fn new_with_options(
        v2_url: Url,
        v3_url: Url,
        options: AccOptions,
    ) -> Result<Self, JsonRpcError> {
        let mut client_builder = Client::builder().timeout(options.timeout);

        // Add custom headers if provided
        if !options.headers.is_empty() {
            let mut headers = reqwest::header::HeaderMap::new();
            for (key, value) in &options.headers {
                let header_name = reqwest::header::HeaderName::from_bytes(key.as_bytes())
                    .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Invalid header name: {}", e)))?;
                let header_value = reqwest::header::HeaderValue::from_str(value)
                    .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Invalid header value: {}", e)))?;
                headers.insert(header_name, header_value);
            }
            client_builder = client_builder.default_headers(headers);
        }

        let http_client = client_builder.build()?;

        let v2_client = JsonRpcClient::with_client(v2_url, http_client.clone())?;
        let v3_client = JsonRpcClient::with_client(v3_url, http_client)?;

        Ok(Self {
            v2_client,
            v3_client,
            options,
        })
    }

    // V2 API Methods

    /// Get node status
    pub async fn status(&self) -> Result<StatusResponse, JsonRpcError> {
        self.v2_client.call_v2("status", None).await
    }

    /// Query transaction by hash
    pub async fn query_tx(&self, hash: &str) -> Result<TransactionResponse, JsonRpcError> {
        self.v2_client.call_v2(&format!("tx/{}", hash), None).await
    }

    /// Query account by URL
    pub async fn query_account(&self, url: &str) -> Result<Account, JsonRpcError> {
        self.v2_client.call_v2(&format!("acc/{}", url), None).await
    }

    /// Request tokens from faucet (DevNet/TestNet only)
    pub async fn faucet(&self, account_url: &str) -> Result<FaucetResponse, JsonRpcError> {
        let payload = json!({
            "account": account_url
        });
        self.v2_client.call_v2("faucet", Some(payload)).await
    }

    /// Submit a transaction to V2 API
    pub async fn submit_v2(&self, tx: &Value) -> Result<TransactionResponse, JsonRpcError> {
        self.v2_client.call_v2("tx", Some(tx.clone())).await
    }

    // V3 API Methods

    /// Submit a single transaction to V3 API using binary codec
    pub async fn submit(&self, envelope: &TransactionEnvelope) -> Result<V3SubmitResponse, JsonRpcError> {
        // Validate envelope structure before submission
        TransactionCodec::validate_envelope(envelope)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Invalid envelope: {}", e)))?;

        // Convert to JSON for API submission
        let envelope_json = serde_json::to_value(envelope)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to serialize envelope: {}", e)))?;

        self.v3_client.call_v3("submit", envelope_json).await
    }

    /// Submit multiple transactions to V3 API using binary codec
    pub async fn submit_multi(&self, envelopes: &[TransactionEnvelope]) -> Result<Vec<V3SubmitResponse>, JsonRpcError> {
        // Validate all envelopes
        for (i, envelope) in envelopes.iter().enumerate() {
            TransactionCodec::validate_envelope(envelope)
                .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Invalid envelope {}: {}", i, e)))?;
        }

        // Convert to JSON for API submission
        let envelopes_json: Result<Vec<Value>, _> = envelopes.iter()
            .map(|env| serde_json::to_value(env))
            .collect();

        let envelopes_json = envelopes_json
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to serialize envelopes: {}", e)))?;

        self.v3_client.call_v3("submitMulti", json!(envelopes_json)).await
    }

    /// Encode envelope to binary format (for testing/debugging)
    pub fn encode_envelope_binary(&self, envelope: &TransactionEnvelope) -> Result<Vec<u8>, JsonRpcError> {
        TransactionCodec::encode_envelope(envelope)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to encode envelope: {}", e)))
    }

    /// Decode envelope from binary format (for testing/debugging)
    pub fn decode_envelope_binary(&self, data: &[u8]) -> Result<TransactionEnvelope, JsonRpcError> {
        TransactionCodec::decode_envelope(data)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to decode envelope: {}", e)))
    }

    /// Query using V3 API
    pub async fn query(&self, url: &str) -> Result<QueryResponse<Account>, JsonRpcError> {
        let params = json!({ "url": url });
        self.v3_client.call_v3("query", params).await
    }

    /// Query block by height using V3 API
    pub async fn query_block(&self, height: i64) -> Result<QueryResponse<Value>, JsonRpcError> {
        let params = json!({ "height": height });
        self.v3_client.call_v3("queryBlock", params).await
    }

    // Transaction Building Helpers

    /// Create a signed transaction envelope using binary codec
    pub fn create_envelope(
        &self,
        principal: String,
        tx_body: &Value,
        keypair: &Keypair,
    ) -> Result<TransactionEnvelope, JsonRpcError> {
        // Get current timestamp in milliseconds (matching TS SDK)
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Time error: {}", e)))?
            .as_millis() as u64;

        // Create envelope using binary codec
        let mut envelope = TransactionCodec::create_envelope(principal, tx_body.clone(), Some(timestamp));

        // Get transaction hash for signing (header + body only)
        let tx_hash = TransactionCodec::get_transaction_hash(&envelope)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to hash transaction: {}", e)))?;

        // Sign the hash
        let signature: Signature = keypair.sign(&tx_hash);

        // Add signature to envelope
        TransactionCodec::add_signature(
            &mut envelope,
            signature.to_bytes().to_vec(),
            format!("acc://unknown/book/1"), // TODO: derive proper signer URL
            Some(keypair.public.to_bytes().to_vec()),
        );

        Ok(envelope)
    }

    /// Create a signed transaction envelope with explicit signer URL
    pub fn create_envelope_with_signer(
        &self,
        principal: String,
        tx_body: &Value,
        keypair: &Keypair,
        signer_url: String,
    ) -> Result<TransactionEnvelope, JsonRpcError> {
        // Get current timestamp in milliseconds (matching TS SDK)
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Time error: {}", e)))?
            .as_millis() as u64;

        // Create envelope using binary codec
        let mut envelope = TransactionCodec::create_envelope(principal, tx_body.clone(), Some(timestamp));

        // Get transaction hash for signing (header + body only)
        let tx_hash = TransactionCodec::get_transaction_hash(&envelope)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Failed to hash transaction: {}", e)))?;

        // Sign the hash
        let signature: Signature = keypair.sign(&tx_hash);

        // Add signature to envelope
        TransactionCodec::add_signature(
            &mut envelope,
            signature.to_bytes().to_vec(),
            signer_url,
            Some(keypair.public.to_bytes().to_vec()),
        );

        Ok(envelope)
    }

    /// Generate a new keypair for signing
    pub fn generate_keypair() -> Keypair {
        let mut rng = rand::thread_rng();
        Keypair::generate(&mut rng)
    }

    /// Create keypair from seed
    pub fn keypair_from_seed(seed: &[u8; 32]) -> Result<Keypair, JsonRpcError> {
        Keypair::from_bytes(seed)
            .map_err(|e| JsonRpcError::General(anyhow::anyhow!("Invalid keypair seed: {}", e)))
    }

    // Utility Methods

    /// Get the base URLs for V2 and V3 clients
    pub fn get_urls(&self) -> (String, String) {
        (
            self.v2_client.base_url.to_string(),
            self.v3_client.base_url.to_string(),
        )
    }

    /// Validate account URL format
    pub fn validate_account_url(url: &str) -> bool {
        // Basic validation - should start with acc:// or be a valid URL format
        url.starts_with("acc://") || url.contains('/')
    }

    /// Create a token transfer transaction body using binary codec
    pub fn create_token_transfer(
        &self,
        to: &str,
        amount: &str,
    ) -> Value {
        TransactionBodyBuilder::send_tokens(vec![
            TokenRecipient {
                url: to.to_string(),
                amount: amount.to_string(),
            }
        ])
    }

    /// Create multiple token transfers in one transaction
    pub fn create_multi_token_transfer(
        &self,
        recipients: Vec<(String, String)>, // (url, amount) pairs
    ) -> Value {
        let token_recipients: Vec<TokenRecipient> = recipients
            .into_iter()
            .map(|(url, amount)| TokenRecipient { url, amount })
            .collect();

        TransactionBodyBuilder::send_tokens(token_recipients)
    }

    /// Create identity creation transaction body using binary codec
    pub fn create_identity(
        &self,
        url: &str,
        key_book_url: &str,
    ) -> Value {
        TransactionBodyBuilder::create_identity(
            url.to_string(),
            key_book_url.to_string(),
        )
    }

    /// Create key book transaction body using binary codec
    pub fn create_key_book(
        &self,
        url: &str,
        public_key_hash: &str,
    ) -> Value {
        TransactionBodyBuilder::create_key_book(
            url.to_string(),
            public_key_hash.to_string(),
        )
    }

    /// Create add credits transaction body using binary codec
    pub fn create_add_credits(
        &self,
        recipient: &str,
        amount: &str,
        oracle: Option<f64>,
    ) -> Value {
        TransactionBodyBuilder::add_credits(
            recipient.to_string(),
            amount.to_string(),
            oracle,
        )
    }

    /// Derive key book URL from identity URL
    pub fn derive_key_book_url(&self, identity_url: &str) -> String {
        UrlHash::derive_key_book_url(identity_url)
    }

    /// Derive key page URL from key book URL and page index
    pub fn derive_key_page_url(&self, key_book_url: &str, page_index: u32) -> String {
        UrlHash::derive_key_page_url(key_book_url, page_index)
    }

    /// Hash URL for identity derivation
    pub fn hash_url(&self, url: &str) -> String {
        UrlHash::hash_url_hex(url)
    }
}

// Additional generated methods would go here if supported by the template data

#[cfg(test)]
mod tests {
    use super::*;
    use url::Url;

    #[tokio::test]
    async fn test_client_creation() {
        let v2_url = Url::parse("http://localhost:26660/v2").unwrap();
        let v3_url = Url::parse("http://localhost:26661/v3").unwrap();
        let options = AccOptions::default();

        let client = AccumulateClient::new_with_options(v2_url, v3_url, options).await;
        assert!(client.is_ok());
    }

    #[test]
    fn test_keypair_generation() {
        let keypair = AccumulateClient::generate_keypair();
        assert_eq!(keypair.public.to_bytes().len(), 32);
    }

    #[test]
    fn test_validate_account_url() {
        assert!(AccumulateClient::validate_account_url("acc://test"));
        assert!(AccumulateClient::validate_account_url("test/account"));
        assert!(!AccumulateClient::validate_account_url("invalid"));
    }

    #[test]
    fn test_create_token_transfer() {
        let client_result = AccumulateClient::new_with_options(
            Url::parse("http://localhost:26660/v2").unwrap(),
            Url::parse("http://localhost:26661/v3").unwrap(),
            AccOptions::default(),
        );

        // We can't await in a non-async test, so we'll just test the sync parts
        let tx = serde_json::json!({
            "type": "sendTokens",
            "data": {
                "from": "acc://alice",
                "to": "acc://bob",
                "amount": "100",
                "token": "acc://ACME"
            }
        });

        assert_eq!(tx["type"], "sendTokens");
        assert_eq!(tx["data"]["amount"], "100");
    }
}