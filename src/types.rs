//! GENERATED BY Accumulate gen-sdk. DO NOT EDIT.

#![allow(missing_docs)]

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Generated types would go here - for now using handcrafted common types

// Common types that are always needed

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StatusResponse {
    pub network: String,
    pub version: String,
    pub commit: String,
    pub node_info: NodeInfo,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct NodeInfo {
    pub id: String,
    pub listen_addr: String,
    pub network: String,
    pub version: String,
    pub channels: String,
    pub moniker: String,
    pub other: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct QueryResponse<T> {
    pub result: T,
    pub height: i64,
    pub proof: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TransactionResponse {
    pub txid: String,
    pub hash: String,
    pub height: i64,
    pub index: i32,
    pub tx: serde_json::Value,
    pub tx_result: TransactionResult,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TransactionResult {
    pub code: i32,
    pub data: Option<String>,
    pub log: String,
    pub info: String,
    pub gas_wanted: String,
    pub gas_used: String,
    pub events: Vec<Event>,
    pub codespace: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Event {
    #[serde(rename = "type")]
    pub event_type: String,
    pub attributes: Vec<Attribute>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Attribute {
    pub key: String,
    pub value: String,
    pub index: bool,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SignedTransaction {
    pub body: serde_json::Value,
    pub signatures: Vec<Signature>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Signature {
    pub public_key: String,
    pub signature: String,
    #[serde(rename = "type")]
    pub signature_type: String,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Account {
    pub url: String,
    #[serde(rename = "type")]
    pub account_type: String,
    pub data: serde_json::Value,
    pub credits: Option<i64>,
    pub nonce: Option<i64>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FaucetResponse {
    /// Transaction ID - may be "txid", "transactionHash", or "hash"
    #[serde(default, alias = "transactionHash", alias = "hash")]
    pub txid: String,
    #[serde(default)]
    pub link: String,
    #[serde(default)]
    pub account: String,
    #[serde(default)]
    pub amount: String,
    /// Simple hash (V3 response)
    #[serde(default, alias = "simpleHash")]
    pub simple_hash: Option<String>,
}

/// Merkle receipt entry - a node in the proof path
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MerkleReceiptEntry {
    /// Whether this hash should be applied on the right side
    #[serde(default)]
    pub right: bool,
    /// The hash value at this position in the proof
    #[serde(with = "hex::serde")]
    pub hash: Vec<u8>,
}

/// Merkle receipt - cryptographic proof of inclusion in a Merkle tree
/// Used for anchoring transactions and proving state inclusion
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MerkleReceipt {
    /// The starting entry hash for which we want a proof
    #[serde(with = "hex::serde")]
    pub start: Vec<u8>,
    /// Index of the start entry in the chain
    #[serde(default)]
    pub start_index: i64,
    /// The ending entry hash at the anchor point
    #[serde(with = "hex::serde")]
    pub end: Vec<u8>,
    /// Index of the end entry in the chain
    #[serde(default)]
    pub end_index: i64,
    /// The Merkle root hash expected after applying all proof entries
    #[serde(with = "hex::serde")]
    pub anchor: Vec<u8>,
    /// The list of hashes in the proof path
    #[serde(default)]
    pub entries: Vec<MerkleReceiptEntry>,
}

impl MerkleReceipt {
    /// Create an empty receipt
    pub fn new() -> Self {
        Self {
            start: Vec::new(),
            start_index: 0,
            end: Vec::new(),
            end_index: 0,
            anchor: Vec::new(),
            entries: Vec::new(),
        }
    }

    /// Validate the receipt structure
    pub fn validate(&self) -> Result<(), crate::errors::Error> {
        use crate::errors::ValidationError;

        // Start hash should be 32 bytes (SHA-256) or empty
        if !self.start.is_empty() && self.start.len() != 32 {
            return Err(ValidationError::InvalidHash {
                expected: 32,
                actual: self.start.len(),
            }.into());
        }

        // End hash should be 32 bytes (SHA-256) or empty
        if !self.end.is_empty() && self.end.len() != 32 {
            return Err(ValidationError::InvalidHash {
                expected: 32,
                actual: self.end.len(),
            }.into());
        }

        // Anchor hash should be 32 bytes (SHA-256) or empty
        if !self.anchor.is_empty() && self.anchor.len() != 32 {
            return Err(ValidationError::InvalidHash {
                expected: 32,
                actual: self.anchor.len(),
            }.into());
        }

        // Validate each entry hash
        for (i, entry) in self.entries.iter().enumerate() {
            if entry.hash.len() != 32 {
                return Err(ValidationError::InvalidFieldValue {
                    field: format!("entries[{}].hash", i),
                    reason: format!("expected 32 bytes, got {}", entry.hash.len()),
                }.into());
            }
        }

        // Start index should not be negative
        if self.start_index < 0 {
            return Err(ValidationError::OutOfRange {
                field: "startIndex".to_string(),
                min: "0".to_string(),
                max: "i64::MAX".to_string(),
            }.into());
        }

        // End index should not be negative
        if self.end_index < 0 {
            return Err(ValidationError::OutOfRange {
                field: "endIndex".to_string(),
                min: "0".to_string(),
                max: "i64::MAX".to_string(),
            }.into());
        }

        // End index should be >= start index
        if self.end_index < self.start_index {
            return Err(ValidationError::InvalidFieldValue {
                field: "endIndex".to_string(),
                reason: format!("endIndex ({}) must be >= startIndex ({})", self.end_index, self.start_index),
            }.into());
        }

        Ok(())
    }

    /// Verify the receipt by computing the Merkle proof
    /// Returns true if applying the entries produces the expected anchor
    pub fn verify(&self) -> Result<bool, crate::errors::Error> {
        use sha2::{Sha256, Digest};

        self.validate()?;

        if self.start.is_empty() || self.anchor.is_empty() {
            return Ok(false);
        }

        let mut current: [u8; 32] = self.start.clone().try_into()
            .map_err(|_| crate::errors::Error::General("Invalid start hash length".to_string()))?;

        // Apply each entry in the proof path
        for entry in &self.entries {
            let entry_hash: [u8; 32] = entry.hash.clone().try_into()
                .map_err(|_| crate::errors::Error::General("Invalid entry hash length".to_string()))?;

            let mut hasher = Sha256::new();
            if entry.right {
                // Entry goes on the right: hash(current || entry)
                hasher.update(&current);
                hasher.update(&entry_hash);
            } else {
                // Entry goes on the left: hash(entry || current)
                hasher.update(&entry_hash);
                hasher.update(&current);
            }
            current = hasher.finalize().into();
        }

        // Compare computed root with expected anchor
        Ok(current.as_slice() == self.anchor.as_slice())
    }

    /// Check if the receipt is empty
    pub fn is_empty(&self) -> bool {
        self.start.is_empty() && self.end.is_empty() && self.anchor.is_empty() && self.entries.is_empty()
    }
}

impl Default for MerkleReceipt {
    fn default() -> Self {
        Self::new()
    }
}

impl std::hash::Hash for MerkleReceipt {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.start.hash(state);
        self.start_index.hash(state);
        self.end.hash(state);
        self.end_index.hash(state);
        self.anchor.hash(state);
        self.entries.hash(state);
    }
}

// V3 specific types
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct V3SubmitRequest {
    pub envelope: TransactionEnvelope,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct V3SubmitResponse {
    pub hash: String,
    pub result: SubmitResult,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SubmitResult {
    pub code: i32,
    pub message: String,
    pub data: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TransactionEnvelope {
    pub transaction: serde_json::Value,
    pub signatures: Vec<V3Signature>,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct V3Signature {
    pub public_key: Vec<u8>,
    pub signature: Vec<u8>,
    pub timestamp: i64,
    pub vote: Option<String>,
}

// ============================================================================
// V3 API Service Types
// ============================================================================

/// Node information returned by NodeInfo service
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3NodeInfo {
    /// The peer ID of this node
    #[serde(default)]
    pub peer_id: String,
    /// Network name
    #[serde(default)]
    pub network: String,
    /// Services provided by this node
    #[serde(default)]
    pub services: Vec<ServiceAddress>,
    /// Node software version
    #[serde(default)]
    pub version: String,
    /// Git commit hash
    #[serde(default)]
    pub commit: String,
}

/// Service address identifying a network service
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ServiceAddress {
    /// Service type identifier
    #[serde(rename = "type")]
    pub service_type: String,
    /// Optional service argument
    #[serde(skip_serializing_if = "Option::is_none")]
    pub argument: Option<String>,
}

/// Options for NodeInfo request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct NodeInfoOptions {
    /// Optional peer ID to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub peer_id: Option<String>,
}

/// Consensus status information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3ConsensusStatus {
    /// Whether the node is operational
    #[serde(default)]
    pub ok: bool,
    /// Last block information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_block: Option<LastBlock>,
    /// Node software version
    #[serde(default)]
    pub version: String,
    /// Git commit hash
    #[serde(default)]
    pub commit: String,
    /// Hash of the node's public key
    #[serde(default)]
    pub node_key_hash: String,
    /// Hash of the validator's public key
    #[serde(default)]
    pub validator_key_hash: String,
    /// Partition identifier
    #[serde(default)]
    pub partition_id: String,
    /// Partition type (Directory, BlockValidator)
    #[serde(default)]
    pub partition_type: String,
    /// Connected peers
    #[serde(default)]
    pub peers: Vec<ConsensusPeerInfo>,
}

/// Last block information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LastBlock {
    /// Block height
    #[serde(default)]
    pub height: i64,
    /// Block timestamp
    #[serde(default)]
    pub time: String,
    /// Chain root hash
    #[serde(default)]
    pub chain_root: String,
    /// State root hash
    #[serde(default)]
    pub state_root: String,
    /// Directory anchor height
    #[serde(default)]
    pub directory_anchor_height: u64,
}

/// Consensus peer information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ConsensusPeerInfo {
    /// Node ID
    #[serde(default)]
    pub node_id: String,
    /// Host address
    #[serde(default)]
    pub host: String,
    /// Port number
    #[serde(default)]
    pub port: u64,
}

/// Options for ConsensusStatus request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ConsensusStatusOptions {
    /// Node ID to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    /// Partition to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// Include connected peers in response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_peers: Option<bool>,
    /// Include Accumulate-specific info
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_accumulate: Option<bool>,
}

/// Network status information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3NetworkStatus {
    /// ACME oracle price information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracle: Option<AcmeOracle>,
    /// Network global settings
    #[serde(skip_serializing_if = "Option::is_none")]
    pub globals: Option<serde_json::Value>,
    /// Network definition
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<serde_json::Value>,
    /// Routing table
    #[serde(skip_serializing_if = "Option::is_none")]
    pub routing: Option<serde_json::Value>,
    /// Active executor version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub executor_version: Option<String>,
    /// Directory network height
    #[serde(default)]
    pub directory_height: u64,
    /// Major block height
    #[serde(default)]
    pub major_block_height: u64,
    /// BVN executor versions
    #[serde(default)]
    pub bvn_executor_versions: Vec<PartitionExecutorVersion>,
}

/// ACME oracle price
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AcmeOracle {
    /// Price in micro-USD per ACME
    #[serde(default)]
    pub price: u64,
}

/// Partition executor version
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PartitionExecutorVersion {
    /// Partition identifier
    #[serde(default)]
    pub partition: String,
    /// Executor version
    #[serde(default)]
    pub version: String,
}

/// Options for NetworkStatus request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct NetworkStatusOptions {
    /// Partition to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
}

/// Metrics information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3Metrics {
    /// Transactions per second
    #[serde(default)]
    pub tps: f64,
}

/// Options for Metrics request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct MetricsOptions {
    /// Partition to query metrics for
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// Window span in blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub span: Option<u64>,
}

/// Submission result for validate/submit operations
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3Submission {
    /// Transaction status
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<serde_json::Value>,
    /// Whether the submission was successful
    #[serde(default)]
    pub success: bool,
    /// Message from the consensus engine
    #[serde(default)]
    pub message: String,
}

/// Options for Submit request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct SubmitOptions {
    /// Verify envelope is well-formed before submitting (default: true)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub verify: Option<bool>,
    /// Wait until envelope is accepted or rejected (default: true)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wait: Option<bool>,
}

/// Options for Validate request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ValidateOptions {
    /// Full validation (default: true)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub full: Option<bool>,
}

/// Options for Faucet request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct V3FaucetOptions {
    /// Token URL (default: ACME)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
}

/// Snapshot information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct V3SnapshotInfo {
    /// Snapshot header
    #[serde(skip_serializing_if = "Option::is_none")]
    pub header: Option<serde_json::Value>,
    /// Consensus genesis document
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_info: Option<serde_json::Value>,
}

/// Options for ListSnapshots request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ListSnapshotsOptions {
    /// Node ID to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub node_id: Option<String>,
    /// Partition to query
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
}

/// Options for FindService request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct FindServiceOptions {
    /// Network to search in
    #[serde(skip_serializing_if = "Option::is_none")]
    pub network: Option<String>,
    /// Service to find
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service: Option<ServiceAddress>,
    /// Restrict to known peers only
    #[serde(skip_serializing_if = "Option::is_none")]
    pub known: Option<bool>,
    /// Timeout for DHT query (milliseconds)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u64>,
}

/// FindService result
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FindServiceResult {
    /// Peer ID
    #[serde(default)]
    pub peer_id: String,
    /// Known peer status
    #[serde(default)]
    pub status: String,
    /// Peer addresses
    #[serde(default)]
    pub addresses: Vec<String>,
}

/// Options for Subscribe (events) request
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct SubscribeOptions {
    /// Partition to subscribe to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// Account to subscribe to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account: Option<String>,
}

// ============================================================================
// V3 Query Types
// ============================================================================

/// Range options for paginated queries
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct RangeOptions {
    /// Starting index
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<u64>,
    /// Number of results to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<u64>,
    /// Expand results with full data
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expand: Option<bool>,
    /// Query from the end of the range
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_end: Option<bool>,
}

/// Receipt options for queries
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ReceiptOptions {
    /// Include receipt for any height
    #[serde(skip_serializing_if = "Option::is_none")]
    pub for_any: Option<bool>,
    /// Include receipt for specific height
    #[serde(skip_serializing_if = "Option::is_none")]
    pub for_height: Option<u64>,
}

/// Default query - basic account/transaction query
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct DefaultQuery {
    /// Include receipt in response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_receipt: Option<ReceiptOptions>,
}

/// Chain query - query chain data for an account
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct ChainQuery {
    /// Chain name (e.g., "main", "signature", "pending")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Query specific index
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<u64>,
    /// Query by entry hash
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<String>,
    /// Range options for paginated results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<RangeOptions>,
    /// Include receipt in response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_receipt: Option<ReceiptOptions>,
}

impl ChainQuery {
    /// Validate the query parameters
    pub fn validate(&self) -> Result<(), crate::errors::Error> {
        let has_name = self.name.is_some();
        let has_index = self.index.is_some();
        let has_entry = self.entry.is_some();
        let has_range = self.range.is_some();

        if has_range && (has_index || has_entry) {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "range".to_string(),
                reason: "range is mutually exclusive with index and entry".to_string(),
            }.into());
        }

        if !has_name && (has_index || has_entry || has_range) {
            return Err(crate::errors::ValidationError::RequiredFieldMissing(
                "name is required when querying by index, entry, or range".to_string(),
            ).into());
        }

        Ok(())
    }
}

/// Data query - query data entries for a data account
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct DataQuery {
    /// Query specific index
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index: Option<u64>,
    /// Query by entry hash
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry: Option<String>,
    /// Range options for paginated results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<RangeOptions>,
}

impl DataQuery {
    /// Validate the query parameters
    pub fn validate(&self) -> Result<(), crate::errors::Error> {
        let has_index = self.index.is_some();
        let has_entry = self.entry.is_some();
        let has_range = self.range.is_some();

        if has_range && (has_index || has_entry) {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "range".to_string(),
                reason: "range is mutually exclusive with index and entry".to_string(),
            }.into());
        }

        Ok(())
    }
}

/// Directory query - query sub-accounts of an identity
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct DirectoryQuery {
    /// Range options for paginated results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<RangeOptions>,
}

/// Pending query - query pending transactions
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct PendingQuery {
    /// Range options for paginated results
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range: Option<RangeOptions>,
}

/// Block query - query block information
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct BlockQuery {
    /// Query by minor block index
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minor: Option<u64>,
    /// Query by major block index
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major: Option<u64>,
    /// Range of minor blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minor_range: Option<RangeOptions>,
    /// Range of major blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub major_range: Option<RangeOptions>,
    /// Range of entries within a block
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry_range: Option<RangeOptions>,
    /// Omit empty (unrecorded) blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub omit_empty: Option<bool>,
}

impl BlockQuery {
    /// Validate the query parameters
    pub fn validate(&self) -> Result<(), crate::errors::Error> {
        let has_minor = self.minor.is_some();
        let has_major = self.major.is_some();
        let has_minor_range = self.minor_range.is_some();
        let has_major_range = self.major_range.is_some();
        let has_entry_range = self.entry_range.is_some();

        if !has_minor && !has_major && !has_minor_range && !has_major_range {
            return Err(crate::errors::ValidationError::RequiredFieldMissing(
                "minor, major, minor_range, or major_range must be specified".to_string(),
            ).into());
        }
        if has_minor && has_major {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "minor/major".to_string(),
                reason: "minor and major are mutually exclusive".to_string(),
            }.into());
        }
        if has_minor_range && has_major_range {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "minor_range/major_range".to_string(),
                reason: "minor_range and major_range are mutually exclusive".to_string(),
            }.into());
        }
        if has_minor && (has_minor_range || has_major_range) {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "minor".to_string(),
                reason: "minor is mutually exclusive with minor_range and major_range".to_string(),
            }.into());
        }
        if has_major && has_major_range {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "major".to_string(),
                reason: "major and major_range are mutually exclusive".to_string(),
            }.into());
        }
        if has_entry_range && (has_major || has_minor_range || has_major_range) {
            return Err(crate::errors::ValidationError::InvalidFieldValue {
                field: "entry_range".to_string(),
                reason: "entry_range is mutually exclusive with major, minor_range, and major_range".to_string(),
            }.into());
        }

        Ok(())
    }
}

/// Anchor search query - search by anchor hash
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AnchorSearchQuery {
    /// Anchor hash to search for (32 bytes, hex-encoded)
    pub anchor: String,
    /// Include receipt in response
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_receipt: Option<ReceiptOptions>,
}

/// Public key search query - search signers by public key
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PublicKeySearchQuery {
    /// Public key to search for (hex-encoded)
    pub public_key: String,
    /// Signature type (e.g., "ed25519", "btc", "eth")
    #[serde(rename = "type")]
    pub signature_type: String,
}

/// Public key hash search query - search signers by public key hash
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PublicKeyHashSearchQuery {
    /// Public key hash to search for (hex-encoded)
    pub public_key_hash: String,
}

/// Delegate search query - search for delegated keys
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DelegateSearchQuery {
    /// Delegate URL to search for
    pub delegate: String,
}

/// Message hash search query - search by message/transaction hash
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MessageHashSearchQuery {
    /// Message hash to search for (32 bytes, hex-encoded)
    pub hash: String,
}

/// Query union type - represents all possible query types
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "queryType", rename_all = "camelCase")]
pub enum V3Query {
    /// Default query for account/transaction
    #[serde(rename = "default")]
    Default(DefaultQuery),
    /// Chain query
    #[serde(rename = "chain")]
    Chain(ChainQuery),
    /// Data query
    #[serde(rename = "data")]
    Data(DataQuery),
    /// Directory query
    #[serde(rename = "directory")]
    Directory(DirectoryQuery),
    /// Pending query
    #[serde(rename = "pending")]
    Pending(PendingQuery),
    /// Block query
    #[serde(rename = "block")]
    Block(BlockQuery),
    /// Anchor search query
    #[serde(rename = "anchorSearch")]
    AnchorSearch(AnchorSearchQuery),
    /// Public key search query
    #[serde(rename = "publicKeySearch")]
    PublicKeySearch(PublicKeySearchQuery),
    /// Public key hash search query
    #[serde(rename = "publicKeyHashSearch")]
    PublicKeyHashSearch(PublicKeyHashSearchQuery),
    /// Delegate search query
    #[serde(rename = "delegateSearch")]
    DelegateSearch(DelegateSearchQuery),
    /// Message hash search query
    #[serde(rename = "messageHashSearch")]
    MessageHashSearch(MessageHashSearchQuery),
}

impl V3Query {
    /// Validate the query
    pub fn validate(&self) -> Result<(), crate::errors::Error> {
        match self {
            V3Query::Chain(q) => q.validate(),
            V3Query::Data(q) => q.validate(),
            V3Query::Block(q) => q.validate(),
            _ => Ok(()),
        }
    }
}
