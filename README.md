# Accumulate Rust SDK (V2/V3 Unified)

A DevNet-first Rust client library for the Accumulate blockchain, providing unified access to both V2 and V3 APIs.

## Features

- **Unified API**: Single client supporting both V2 and V3 protocols
- **DevNet-first**: Optimized for local development with DevNet instances
- **Zero-to-hero**: Complete examples from basic connectivity to transaction submission
- **Fully tested**: Unit tests and integration tests with mocking support
- **Generated core**: Core client methods generated from OpenAPI specifications
- **Type-safe**: Comprehensive Rust types with serde support
- **Async/await**: Modern async Rust with tokio

## Quick Start

Add to your `Cargo.toml`:

```toml
[dependencies]
accumulate-client = "0.1.0"
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
```

### Basic Usage

```rust
use accumulate_client::{AccOptions, AccumulateClient};
use url::Url;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to DevNet
    let v2_url = Url::parse("http://localhost:26660/v2")?;
    let v3_url = Url::parse("http://localhost:26660/v3")?;
    let client = AccumulateClient::from_endpoints(v2_url, v3_url, AccOptions::default()).await?;

    // Get network status
    let status = client.status().await?;
    println!("Network: {}", status.network);

    Ok(())
}
```

### Network Configuration

```rust
use accumulate_client::{AccOptions, AccumulateClient};
use url::Url;

// DevNet (default: localhost:26660)
let v2_url = Url::parse("http://localhost:26660/v2")?;
let v3_url = Url::parse("http://localhost:26660/v3")?;
let client = AccumulateClient::from_endpoints(v2_url, v3_url, options).await?;

// Custom network
let v2_url = Url::parse("http://my-node:8080/v2")?;
let v3_url = Url::parse("http://my-node:8080/v3")?;
let client = AccumulateClient::from_endpoints(v2_url, v3_url, options).await?;
```

### Transaction Creation and Signing

```rust
use accumulate_client::AccumulateClient;

// Generate keypair
let keypair = AccumulateClient::generate_keypair();

// Create transaction body
let tx_body = client.create_token_transfer(
    "acc://alice",
    "acc://bob",
    100, // amount
    None // use default ACME token
);

// Create signed envelope for V3 API
let envelope = client.create_envelope(&tx_body, &keypair)?;

// Submit to network
let result = client.submit(&envelope).await?;
println!("Transaction hash: {}", result.hash);
```

## Examples

The SDK includes comprehensive examples for DevNet integration:

### DevNet Setup and Discovery

```bash
# 1. Start with DevNet discovery
cargo run --bin devnet_discovery

# This creates .env.local with discovered endpoints
```

### Step-by-Step Examples

```bash
# 2. Learn key generation and URL patterns
cargo run --example 100_keygen_lite_urls

# 3. Fund accounts with faucet
cargo run --example 120_faucet_local_devnet

# 4. Buy credits for transactions
cargo run --example 210_buy_credits_lite

# 5. Complete zero-to-hero workflow
cargo run --example 999_zero_to_hero
```

### Environment Configuration

The examples use `.env.local` created by DevNet discovery:

```bash
# Generated by devnet_discovery
ACC_DEVNET_DIR=C:\path\to\devnet-accumulate-instance
ACC_RPC_URL_V2=http://localhost:26660/v2
ACC_RPC_URL_V3=http://localhost:26660/v3
ACC_FAUCET_ACCOUNT=acc://faucet.acme/ACME
```

## API Reference

### Client Creation

- `AccumulateClient::from_endpoints(v2_url, v3_url, options)` - Connect to custom V2/V3 endpoints

### V2 API Methods

- `client.status()` - Get node status
- `client.query_tx(hash)` - Query transaction by hash
- `client.query_account(url)` - Query account by URL
- `client.faucet(account)` - Request test tokens (DevNet/TestNet)
- `client.submit_v2(tx)` - Submit V2 transaction

### V3 API Methods

- `client.submit(envelope)` - Submit single transaction
- `client.submit_multi(envelopes)` - Submit multiple transactions
- `client.query(url)` - Query using V3 API
- `client.query_block(height)` - Query block by height

### Transaction Helpers

- `client.create_envelope(tx, keypair)` - Create signed transaction envelope
- `client.create_token_transfer(from, to, amount, token)` - Create token transfer
- `client.create_account(url, pubkey, type)` - Create account creation transaction
- `AccumulateClient::generate_keypair()` - Generate new keypair
- `AccumulateClient::keypair_from_seed(seed)` - Create keypair from seed

### Utilities

- `client.get_urls()` - Get V2/V3 API URLs
- `client.validate_account_url(url)` - Validate account URL format
- `canonical_json(value)` - Create deterministic JSON for hashing

## Configuration

### AccOptions

```rust
use std::time::Duration;

let mut headers = std::collections::HashMap::new();
headers.insert("Authorization".to_string(), "Bearer token".to_string());

let options = AccOptions {
    timeout: Duration::from_secs(60),
    headers,
};
```

### Features

- `default = ["rustls-tls"]` - Use rustls for TLS
- `rustls-tls` - Enable rustls TLS backend

## Testing

```bash
# Unit tests
cargo test

# Conformance tests (TS parity)
cargo test conformance --all-features

# All tests including demos
cargo test --all-features

# Test with tracing output
RUST_LOG=debug cargo test
```

## Parity Gate

The Rust SDK maintains byte-for-byte compatibility with the TypeScript SDK through comprehensive parity testing. The parity gate verifies:

- **Canonical JSON**: Identical deterministic serialization
- **Cryptographic parity**: Ed25519 signatures match exactly
- **Transaction hashes**: SHA-256 hashes identical between SDKs
- **Binary encoding**: Protocol buffers roundtrip correctly
- **Fuzzing**: 1000+ random TypeScript-generated test vectors

### Running the Parity Gate

```bash
# Run complete parity validation pipeline
scripts\run_parity_gate.ps1

# Custom fuzz count and coverage threshold
scripts\run_parity_gate.ps1 -FuzzCount 2000 -CoverageThreshold 80
```

### Expected Output

```
ğŸš€ ACCUMULATE RUST SDK PARITY GATE
===================================

ğŸ“ Entering unified directory...
ğŸ”§ Generating TypeScript fixtures...
  â†’ Generating standard fixtures...
  â†’ Generating random test vectors (n=1000)...
  âœ… Generated 1000 random test vectors
ğŸ¨ Formatting Rust code...
  âœ… Code formatting complete
ğŸ” Running Clippy linter...
  âœ… Linting passed with no warnings
ğŸ›¡ï¸  Running quality gates...
  â†’ Checking for TODOs and stubs...
  âœ… No prohibited patterns found
ğŸ§ª Running core functionality tests...
  â†’ Testing canonical JSON implementation...
  â†’ Testing cryptographic functions...
  â†’ Testing codec functionality...
  âœ… Core functionality tests passed
ğŸ”„ Running parity and roundtrip tests...
  â†’ Testing TypeScript fuzzing roundtrip...
  â†’ Testing type matrix roundtrips...
  â†’ Verifying type matrix coverage...
  âœ… All parity and roundtrip tests passed
ğŸ¯ Running complete test suite...
  âœ… All tests passed
ğŸ“Š Analyzing code coverage...
  âœ… Coverage threshold of 70% achieved

ğŸ“‹ PARITY GATE SUMMARY
======================
ğŸ“¦ Golden fixtures: 15 files
ğŸ² Fuzz vectors: 1000 envelopes
ğŸ¯ Test coverage: 70% threshold
ğŸ”„ Type matrix: 27 protocol types

ğŸŸ¢ Parity locked: binary, canonical JSON, hashes, signatures, fuzz roundtrip = OK

âœ… All parity gates passed successfully!
   The Rust SDK maintains byte-for-byte compatibility with TypeScript SDK
```

### Components

The parity gate executes:

1. **TypeScript Fixture Generation**: Creates deterministic test vectors
2. **Code Quality**: Formatting, linting, and prohibition scanning
3. **Core Tests**: Canonical JSON, cryptography, and codec validation
4. **Roundtrip Verification**: Type matrix and fuzzing roundtrips
5. **Coverage Analysis**: Ensures adequate test coverage (configurable threshold)

## Production Tooling

The SDK includes comprehensive production-ready tooling:

### Code Quality

```bash
# Format code
make fmt

# Run lints
make lint

# Full development checks
make dev
```

### Coverage Analysis

```bash
# Generate coverage report
make coverage

# Run coverage gates (70% overall, 85% critical)
scripts/coverage_gate.sh

# Coverage with HTML report
cargo llvm-cov --all-features --html
```

### Package Validation

```bash
# Check package readiness
scripts/package_check.sh

# Test documentation builds
cargo doc --all-features --no-deps -D warnings

# Dry-run publish
cargo publish --dry-run
```

### CI Integration

The project includes GitHub Actions workflows for:
- **CI**: Format, lint, test, coverage across Windows/Linux
- **Release**: Automated publishing to crates.io on version tags
- **Security**: Dependency auditing and vulnerability scanning

## Development

### Running DevNet

Start the local DevNet instance:

```bash
cd /path/to/devnet-accumulate-instance
./start-devnet.sh
```

DevNet URLs:
- V2 API: http://localhost:26660/v2
- V3 API: http://localhost:26661/v3

### Regenerating Code

The core client, types, and JSON-RPC client are generated from templates:

```bash
# Regenerate from OpenAPI spec
cd /path/to/accumulate
./tools/cmd/gen-sdk/gen-sdk.exe ./pkg/api/v3/openapi.yml \
  --lang rust \
  --template-dir "/path/to/opendlt-rust-v2v3-sdk/tooling/templates" \
  --out "/path/to/opendlt-rust-v2v3-sdk/unified/src" \
  --unified --api-version both

# Format generated code
cargo fmt
```

**Important**: The generated files are read-only. To modify behavior, update the templates in `tooling/templates/` and regenerate.

### Templates

Templates are located in `tooling/templates/`:

- `client.rs.tmpl` - Main client implementation
- `json_rpc_client.rs.tmpl` - JSON-RPC client with V2/V3 support
- `types.rs.tmpl` - Serde-compatible type definitions

## Architecture

```
unified/
â”œâ”€â”€ Cargo.toml              # Dependencies and metadata
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs             # Public facade (handwritten)
â”‚   â”œâ”€â”€ client.rs          # Generated client implementation
â”‚   â”œâ”€â”€ json_rpc_client.rs # Generated JSON-RPC client
â”‚   â””â”€â”€ types.rs           # Generated type definitions
â”œâ”€â”€ examples/              # Zero-to-hero examples
â”œâ”€â”€ tests/                 # Unit and integration tests
â””â”€â”€ tooling/templates/     # Code generation templates
```

## Error Handling

All API methods return `Result<T, JsonRpcError>`:

```rust
use accumulate_client::JsonRpcError;

match client.status().await {
    Ok(status) => println!("Success: {:?}", status),
    Err(JsonRpcError::Http(e)) => eprintln!("HTTP error: {}", e),
    Err(JsonRpcError::Rpc { code, message }) => eprintln!("RPC error {}: {}", code, message),
    Err(e) => eprintln!("Other error: {}", e),
}
```

## License

MIT License - see LICENSE file for details.

## Contributing

1. Fork the repository
2. Create your feature branch
3. Make changes to templates (not generated files)
4. Run `cargo fmt` and `cargo clippy`
5. Add tests for new functionality
6. Submit a pull request

Generated code should not be edited directly - modify templates and regenerate instead.